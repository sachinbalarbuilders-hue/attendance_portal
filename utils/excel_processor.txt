import pandas as pd
import datetime
from openpyxl import load_workbook

def is_font_red(cell):
    """Check if font color is specifically red or red-like"""
    if cell is None or cell.font is None:
        return False
    
    color = cell.font.color
    if color is None:
        return False
    
    # Handle RGB colors - check for red shades
    if color.type == "rgb" and color.rgb is not None:
        rgb_val = color.rgb.upper()
        # Common red color values in Excel (ARGB format)
        red_colors = [
            "FFFF0000",  # Pure red
            "FF0000",    # Red without alpha
            "FFDC143C",  # Crimson
            "FFB22222",  # Fire brick
            "FF8B0000",  # Dark red
            "FFCD5C5C",  # Indian red
            "FFF08080",  # Light coral
            "FFFA8072",  # Salmon
            "FFFF6347",  # Tomato
            "FFFF1493",  # Deep pink (reddish)
        ]
        return rgb_val in red_colors
    
    # Handle indexed colors - check for red indices
    elif color.type == "indexed" and color.indexed is not None:
        # Common red color indices in Excel
        red_indices = [3, 5, 10, 53]  # These are typical red color indices
        return color.indexed in red_indices
    
    # Handle theme colors
    elif color.type == "theme" and color.theme is not None:
        # Theme color 2 is often red in many Excel themes
        return color.theme == 2
    
    return False

def process_attendance_file(file_path, selected_date=None):
    """Process attendance data from Excel file with RED font color detection"""
    if selected_date is None:
        selected_date = datetime.date.today()
        
    wb = load_workbook(file_path, data_only=False)  # Keep data_only=False to preserve formatting
    visible_sheets = [sheet for sheet in wb.worksheets if sheet.sheet_state == "visible"]
    
    month_abbr = selected_date.strftime("%b").upper()
    year = selected_date.year
    day_limit = selected_date.day

    blank_employees = [
        "Bhavin Patel",
        "Pramod Dubey", 
        "Shrikant Talekar",
        "Jitendra Patolia",
        "Lalit Dobariya"
    ]

    def to_ts(x):
        if x is None or (isinstance(x, float) and pd.isna(x)):
            return pd.NaT
        
        # Handle datetime.time objects directly
        if isinstance(x, datetime.time):
            return datetime.datetime.combine(datetime.date.today(), x)
        
        # Handle string time formats that might be manually entered
        if isinstance(x, str):
            x = x.strip()
            # Try common time formats first
            time_formats = [
                "%H:%M",      # 09:30
                "%H:%M:%S",   # 09:30:00
                "%I:%M %p",   # 9:30 AM
                "%I:%M:%S %p", # 9:30:00 AM
                "%H.%M",      # 09.30
                "%I.%M %p",   # 9.30 AM
            ]
            
            for fmt in time_formats:
                try:
                    # Parse as time and convert to datetime
                    time_obj = datetime.datetime.strptime(x, fmt).time()
                    # Create a datetime with today's date and the parsed time
                    return datetime.datetime.combine(datetime.date.today(), time_obj)
                except ValueError:
                    continue
        
        try:
            return pd.to_datetime(x, errors="coerce")
        except Exception:
            return pd.NaT

    records = []

    for sheet in visible_sheets:
        df = pd.read_excel(file_path, sheet_name=sheet.title, header=None)
        if df.dropna(how="all").empty:
            continue

        # Updated logic to handle both old format (JAN, MAY, etc.) and new format (NOV-24, DEC-24, JAN-25, etc.)
        month_rows = []
        for i in range(len(df)):
            cell_value = str(df.iloc[i, 0]).upper()
            
            # Check for old format (JAN, MAY, etc.)
            if cell_value == month_abbr and len(cell_value) == 3:
                month_rows.append(i)
            # Check for new format (NOV-24, DEC-24, JAN-25, etc.)
            elif cell_value.startswith(month_abbr) and len(cell_value) == 6 and '-' in cell_value and cell_value[3] == '-':
                # Extract year from Excel (e.g., "24" from "NOV-24")
                excel_year_str = cell_value[4:6]
                try:
                    excel_year = int(excel_year_str)
                    # Convert to full year (24 -> 2024, 25 -> 2025, etc.)
                    excel_full_year = 2000 + excel_year
                    
                    # Check if the year matches the selected date year
                    if excel_full_year == year:
                        month_rows.append(i)
                except ValueError:
                    # If year parsing fails, skip this row
                    continue
        if not month_rows:
            continue
        i = month_rows[0]

        for d in range(1, day_limit + 1):
            col = d + 2
            if col >= df.shape[1]:
                continue

            date_val = datetime.date(year, selected_date.month, d).strftime('%Y-%m-%d')
            status_row = i + 2
            status = ""
            if status_row < len(df):
                s = df.iloc[status_row, col]
                if pd.notna(s):
                    status = str(s).upper().strip()

            # Get cells for formatting info
            pin_cell = wb[sheet.title].cell(i + 1, col + 1)
            pout_cell = wb[sheet.title].cell(i + 2, col + 1) if i + 1 < len(df) else None
            status_cell = wb[sheet.title].cell(status_row + 1, col + 1) if status_row < len(df) else None

            # Comments logic - store separately
            pin_comment, pout_comment, status_comment = "", "", ""
            try:
                if pin_cell and pin_cell.comment:
                    pin_comment = pin_cell.comment.text
                if pout_cell and pout_cell.comment:
                    pout_comment = pout_cell.comment.text
                if status_cell and status_cell.comment:
                    status_comment = status_cell.comment.text
            except:
                pass

            # RED font color detection
            pin_highlight = is_font_red(pin_cell) if pin_cell else False
            pout_highlight = is_font_red(pout_cell) if pout_cell else False
            status_highlight = is_font_red(status_cell) if status_cell else False

            # Punch logic (same as before)
            if status in ["A", "W/O", "PL", "SL", "FL", "HL"]:
                pin, pout = "--", "--"
            elif sheet.title.strip() in blank_employees:
                pin, pout = "", ""
            else:
                raw1 = df.iloc[i, col] if pd.notna(df.iloc[i, col]) else None
                raw2 = df.iloc[i + 1, col] if i + 1 < len(df) and pd.notna(df.iloc[i + 1, col]) else None
                t1, t2 = to_ts(raw1), to_ts(raw2)

                if pd.notna(t1) and pd.notna(t2):
                    pin, pout = t1.strftime("%H:%M"), t2.strftime("%H:%M")
                elif pd.notna(t1) and pd.isna(t2):
                    if t1.hour >= 12:
                        pin, pout = "❌ Missing", t1.strftime("%H:%M")
                    else:
                        pin, pout = t1.strftime("%H:%M"), "❌ Missing"
                elif pd.isna(t1) and pd.notna(t2):
                    if t2.hour >= 12:
                        pin, pout = "❌ Missing", t2.strftime("%H:%M")
                    else:
                        pin, pout = t2.strftime("%H:%M"), "❌ Missing"
                else:
                    pin, pout = "❌ Missing", "❌ Missing"

            # Store everything including comments and RED highlighting info
            records.append({
                "Employee": sheet.title,
                "Date": date_val,
                "Punch-In": pin,
                "Punch-Out": pout,
                "Status": status,
                "pin_comment": pin_comment,
                "pout_comment": pout_comment,
                "status_comment": status_comment,
                "pin_highlight": pin_highlight,
                "pout_highlight": pout_highlight,
                "status_highlight": status_highlight
            })

    return records
